#version 460
#extension GL_KHR_vulkan_glsl : enable
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;

#include "assets/Shaders/hash_functions.glsl"

layout(push_constant) uniform constants {
    vec4 data1; // Ground color xyz and w starfield threshold
    vec4 data2; // Sky color xyz
    vec4 data3; // Unused in current code
    vec4 data4; // camera quaternion
} PushConstants;

vec3 applyQuaternion(vec3 v, vec4 q) {
    vec3 qVec = q.xyz;
    float qW = q.w;

    vec3 uv = cross(qVec, v);
    vec3 uuv = cross(qVec, uv);

    uv *= (2.0 * qW);
    uuv *= 2.0;

    return v + uv + uuv;
}

vec3 applyCameraRotation(vec3 direction, vec4 quat) {
    quat.x = -quat.x;
    quat.z = -quat.z;

    return normalize(applyQuaternion(direction, quat));
}

void main() {
    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(image);
    
    vec2 uv = (vec2(storePos) + 0.5) / vec2(imgSize);
    uv = uv * 2.0 - 1.0;

    vec3 direction = normalize(vec3(uv, 1.0));
    direction = applyCameraRotation(direction, PushConstants.data4);

    vec3 groundColor = vec3(PushConstants.data1.rgb);
    vec3 skyColor = vec3(PushConstants.data2.rgb);

    float t = (direction.y + 1.0) * 0.5;
    vec3 color = mix(groundColor, skyColor, t);

    float starThreshold = PushConstants.data1.a;
    if (direction.y < 0.0) {
        vec3 worldPos =  direction * 100.0;
        float starValue = hash13(worldPos);

        // Reverse fading direction
        float fade = smoothstep(0.0, -1.0, direction.y);

        if (starValue > starThreshold) {
            color = mix(color, vec3(1.0), fade);
        }
    }

    imageStore(image, storePos, vec4(color, 1.0));
}
